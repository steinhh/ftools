Python call example:
------------------------------------------------------------------------------
from ftools import fmpfit
functkw = {'x': xdata, 'y': ydata, 'error': y_sigma}
parinfo = [{'value':p0[i], 'fixed':0, 'limited':[1,1],
    'limits':[bounds[0][i],bounds[1][i]]} for i in range(len(p0))]

mp_ = mpfit(deviates,parinfo=parinfo, functkw=functkw, xtol=1.0E-6, ftol=1.0E-6, gtol=1.0E-6,
                        maxiter=2000, quiet=1)

------------------------------------------------------------------------------
Core C function signature (to be called by the wrapper):
------------------------------------------------------------------------------
fmpfit_core(double x[], double y[], double error[], double p0[], double bounds[][2],
            int32 mpoints, int32 npar, int32 deviate_type,
            double xtol, double ftol, double gtol,
            int32 maxiter, int32 quiet,
            double best_params[], double *bestnorm, double *orignorm,
            int32 *niter, int32 *nfev, int32 *status,
            double resid[], double xerror[], double covar[][]);
------------------------------------------------------------------------------
------------------------------------------------------------------------------
Ignore following for now ---
C function to be called by fmpfit_core:
------------------------------------------------------------------------------
int mpfit(mp_func funct, int mpoints, int npar,
          double xall[npar], mp_par pars[npar], mp_config *config, 
          void *private_data, 
          mp_result *diagnostics);

funct: [ gaussian ] deviates function
m: number of data points
npar: number of parameters
xall (p): parameter values (set to initial guesses, best values on return)
pars: parameter structures (limits, etc.)
config: configuration structure (tolerances, max iterations, etc.)
private_data: pointer to user-defined data (if needed)
result: structure to store the fitting results (chi-square, status, etc.)

Typedef mp_par:

typedef struct {
  int fixed;        /* 1 = fixed; 0 = free */
  int limited[2];   /* 1 = low/upper limit; 0 = no limit */
  double limits[2]; /* lower/upper limit boundary value */

  char *parname;    /* Name of parameter, or 0 for none */
  double step;      /* Step size for finite difference */
  double relstep;   /* Relative step size for finite difference */
  int side;         /* Sidedness of finite difference derivative 
                       0 - one-sided derivative computed automatically
                       1 - one-sided derivative (f(x+h) - f(x)  )/h
                      -1 - one-sided derivative (f(x)   - f(x-h))/h
                       2 - two-sided derivative (f(x+h) - f(x-h))/(2*h) 
                       3 - user-computed analytical derivatives
                    */
  int deriv_debug;  /* Derivative debug mode: 1 = Yes; 0 = No; */
  double deriv_reltol; /* Relative tolerance for derivative debug printout */
  double deriv_abstol; /* Absolute tolerance for derivative debug printout */
} mp_par;

Typedef mp_result:

typedef struct {
  double bestnorm;     /* Final chi^2 */
  double orignorm;     /* Starting value of chi^2 */
  int niter;           /* Number of iterations */
  int nfev;            /* Number of function evaluations */
  int status;          /* Fitting status code */
  
  int npar;            /* Total number of parameters */
  int nfree;           /* Number of free parameters */
  int npegged;         /* Number of pegged parameters */
  int nfunc;           /* Number of residuals (= num. of data points) */

  double *resid;       /* Final residuals nfunc-vector, or 0 if not desired */
  double *xerror;      /* Final parameter uncertainties (1-sigma) npar-vector, or 0 if not desired */
  double *covar;       /* Final parameter covariance matrix npar x npar array, or 0 if not desired */
  char version[20];    /* MPFIT version string */
} mp_result;


-------------------------------------------------------------------------------

struct private_data {
    double *x;         /* x - independent variable of model */
    double *y;         /* y - measured "y" values */
    double *y_error;   /* y_error - measurement uncertainty in y */
  };

double model_function(double x, double *par)
  {
    /* Example: Gaussian model */
    double A = par[0];      /* Amplitude */
    double mu = par[1];     /* Mean */
    double sigma = par[2];  /* Standard deviation */

    return A * exp(-0.5 * pow((x - mu) / sigma, 2));
  }

int myfunct(int m, int npar, double *p, double *deviates,
              double **derivs, void *private)
  {
    int i;

    for (i=0; i<m; i++) {
      deviates[i] = (data->y[i] - model_function(data->x[i], p)) / data->y_error[i];
    }

    if (derivs) {
      int j;
      for (j=0; j<npar; j++) if (derivs[j]) {
        for (i=0; i<m; i++) {
          derivs[j][i] = {d(deviates[i])/d(par[j])}
        }
      }
    }

    return 0;
  }

The user function parameters are defined as follows:
  int m     - number of data points
  int npar     - number of parameters
  double *p - array of n parameters 
  double *deviates - array of m deviates to be returned by myfunct()
  double **derivs - used for user-computed derivatives (see below)
                    (= 0  when automatic finite differences are computed)

